Запуск -Xmx10m -XX:+UseParallelGC

Попробовал три инструмента.

В Jconsole можно смотреть регионы памяти, с подсчётом сборок и времени. Но почему-то в режиме простоя трекера, память чем-то постоянно забивается, вызывая постоянные сборки мусора. Размер выделенной памяти под кучу верный - 10мб. Оценить работу кода не смог, пробовал запускать несколько раз.

VisualGC в отличии от двух остальных полностью стабилен, идеально ровное поведение в простое. Единственное при запуске кода в IDE с ограниченной кучей(10мб) происхдоят GC и первые числа сборок и времени надо отнимать от итоговых показателей.

Jprofiler в простое так же пишет данные в память, но на больших временных отрезках думаю это не критично. Время/кол-во сборок не нашёл, есть временная шкала с динамикой разных видов сборок GC(малой/большой). Хаотичного потребления памяти с частыми сборками не происходит, UseParallelGC подходит для данного приложения.
 Как и у предыдущих профайлеров, есть информация о регионах памяти + дополнительно содержимое кучи по типам объектов присутствующих классов. Возможно точно проследить общее кол-во созданных элементов нужных нам классов, как живых так и объектов попавших под GC. Видно что было созданно столько то Item-ов.
При добавленнии какого-то кол-ва данных в трекер и нескольких циклов GC можно сказать что минимально необходимо иметь под нужды самого приложения около 2.4Мб + предусмотренный запас памяти для базы данных - items  ArrayList. Размер памяти под базу зависит от типа данных полей и их кол-ва. В нашем случае вес маленький, у нас лишь два поля - String id и String name.
С максимальным размером всё иначе. Наблюдая за динамикой потребления памяти можно сказать что максимально потребляется в моменты вывода всех Item. Тоесть в тех участках кода где создаются большие коллекции ArrayList для вывода/обработки.
Имеем необходимыйй минимум МБ + база + запас памяти для вывода всей базы. Для этого приложения большая база потребует дополнительную память. Для большой базы лучше делать методы, которые читают/пишут кусками, перемещая указатель по базе.

Возможность просматривать кучу на конкретный момент времени позволяет выявить основные затраты памяти, оптимизировать расход памяти.
Можно немножко оптимизировать выполнение. Видно что каждый раз для Item создаётся новый экземпляр класса Random в методе String generateId() class MemTracker.